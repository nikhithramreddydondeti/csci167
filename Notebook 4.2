def shallow_1_1_3_3(x, activation_fn, phi, psi, theta):
    # Layer 1 preactivations
    layer1_pre_1 = theta[1,0] + theta[1,1] * x
    layer1_pre_2 = theta[2,0] + theta[2,1] * x
    layer1_pre_3 = theta[3,0] + theta[3,1] * x

    # Layer 1 activations
    h1 = activation_fn(layer1_pre_1)
    h2 = activation_fn(layer1_pre_2)
    h3 = activation_fn(layer1_pre_3)

    # Layer 2 preactivations
    layer2_pre_1 = psi[1,0] + psi[1,1]*h1 + psi[1,2]*h2 + psi[1,3]*h3
    layer2_pre_2 = psi[2,0] + psi[2,1]*h1 + psi[2,2]*h2 + psi[2,3]*h3
    layer2_pre_3 = psi[3,0] + psi[3,1]*h1 + psi[3,2]*h2 + psi[3,3]*h3

    # Layer 2 activations
    h1_prime = activation_fn(layer2_pre_1)
    h2_prime = activation_fn(layer2_pre_2)
    h3_prime = activation_fn(layer2_pre_3)

    # Weighted outputs
    phi1_h1_prime = phi[1]*h1_prime
    phi2_h2_prime = phi[2]*h2_prime
    phi3_h3_prime = phi[3]*h3_prime

    # Final output
    y = phi[0] + phi1_h1_prime + phi2_h2_prime + phi3_h3_prime

    return (y, layer2_pre_1, layer2_pre_2, layer2_pre_3,
            h1_prime, h2_prime, h3_prime,
            phi1_h1_prime, phi2_h2_prime, phi3_h3_prime)
